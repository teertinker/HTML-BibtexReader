<!DOCTYPE html>
<html lang="eng">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BibTeX Reader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #4c4e52;
            color: #c9d1d9;
            min-height: 100vh;
            line-height: 1.5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 16px;
            text-align: center;
        }

        .header h1 {
            color: #58a6ff;
            font-size: 2.5em;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .header p {
            color: #8b949e;
            font-size: 1.1em;
        }

.controls {
    position: relative;
    background: #161b22;
    border: 1px solid #30363d;
    border-radius: 6px;
    padding: 20px;
    margin-bottom: 16px;
}

        .file-input-container {
            margin-bottom: 16px;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            background: #238636;
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 500;
            transition: all 0.2s ease;
            border: 1px solid #238636;
            font-size: 14px;
        }

        .file-input-wrapper:hover {
            background: #2ea043;
            border-color: #2ea043;
        }

        .file-input-wrapper:active {
            background: #1f7134;
            border-color: #1f7134;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .search-container {
            position: relative;
            margin-bottom: 16px;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #30363d;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: #4c4e52;
            color: #c9d1d9;
        }

        .search-input:focus {
            outline: none;
            border-color: #58a6ff;
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.2);
        }

        .search-input::placeholder {
            color: #6e7681;
        }

        .search-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #6e7681;
            font-size: 16px;
        }

        .search-filters {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 4px 8px;
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 4px;
            color: #8b949e;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .filter-btn:hover {
            background: #30363d;
            border-color: #58a6ff;
        }

        .filter-btn.active {
            background: #58a6ff;
            border-color: #58a6ff;
            color: #ffffff;
        }

        .sort-options {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .sort-select {
            padding: 4px 8px;
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 4px;
            color: #8b949e;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .sort-select:hover {
            background: #30363d;
            border-color: #58a6ff;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #8b949e;
            font-size: 12px;
            padding-top: 8px;
            border-top: 1px solid #21262d;
        }

        .entries-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
            margin-bottom: 16px;
        }

        .entry-card {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;

        }

        .entry-card:hover {
            border-color: #58a6ff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .entry-card:active {
            transform: scale(0.98);
        }

        .entry-card.pinned {
            border-color: #ffd33d;
            box-shadow: 0 0 0 1px rgba(255, 211, 61, 0.3);
        }

        .entry-author {
            color: #58a6ff;
            font-weight: 500;
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
             word-break: break-word;
        }

        .entry-title {
            color: #c9d1d9;
            font-size: 16px;
            font-weight: 600;
            line-height: 1.3;
            margin-bottom: 12px;
            word-break: break-word;
        }

        .entry-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            color: #8b949e;
            font-size: 12px;
        }

        .entry-year {
            background: #21262d;
            color: #f0f6fc;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 500;
            border: 1px solid #30363d;
        }

        .entry-keywords {
            color: #ff7b72;
            font-size: 11px;
            font-weight: 400;
            margin-top: 8px;
            word-break: break-word;
        }

        .entry-indicators {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 8px;
        }

        .entry-priority {
            color: #ffffff;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 500;
            display: inline-block;
        }

        .entry-ranking {
            color: #ffd33d;
            font-size: 14px;
        }

        .pin-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
         
        }

        .pin-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #ffd33d;
        }

        .pin-btn.pinned {
            color: #ffd33d;
                  background: rgba(255, 255, 255, 0.1);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #4c4e52;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px;
            padding-top: 0px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            width: 90%;
        }

        .modal-header {
            display: flex;
            position: sticky;
            top: 0;
            justify-content: flex-end;
             align-items: center;
             padding: 1px;
            margin: 0;
        }
          
        }

        .modal-title {
            color: #f0f6fc;
            font-size: 20px;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            color: #8b949e;
            transition: color 0.2s ease;
            padding: 4px;
        }

        .close-btn:hover {
            color: #58a6ff;
        }

        .detail-item {
            margin-bottom: 16px;
            padding: 12px;
            background: #161b22;
            border-radius: 6px;
            border: 1px solid #21262d;
        }

        .detail-label {
            font-weight: 500;
            color: #58a6ff;
            margin-bottom: 4px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .detail-value {
            color: #c9d1d9;
            line-height: 1.4;
            font-size: 14px;
        }

        .detail-value a {
            color: #58a6ff;
            text-decoration: none;
        }

        .detail-value a:hover {
            text-decoration: underline;
        }

        .abstract-content {
            white-space: pre-wrap;
        }

        .abstract-content h1, .abstract-content h2, .abstract-content h3 {
                    margin: 16px 0 8px 0;
            font-weight: 600;
        }

        .abstract-content h1 { font-size: 18px; }
        .abstract-content h2 { font-size: 16px; }
        .abstract-content h3 { font-size: 14px; }

        .abstract-content ul, .abstract-content ol {
            margin: 8px 0;
            padding-left: 20px;
        }

        .abstract-content li {
            margin: 4px 0;
        }

        .abstract-content strong {
      
            font-weight: 600;
        }

        .abstract-content em {
          
            font-style: italic;
        }

        .abstract-content code {
            background: #161b22;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #8b949e;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.6;
        }

        .empty-state h3 {
            color: #f0f6fc;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #238636;
            color: #ffffff;
            padding: 12px 16px;
            border-radius: 6px;
            border: 1px solid #238636;
            z-index: 1001;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .notification.show {
            transform: translateX(0);
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #161b22;
        }

        ::-webkit-scrollbar-thumb {
            background: #30363d;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #484f58;
        }

        @media (max-width: 768px) {
            .container {
                padding: 12px;
            }

            .entries-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .modal-content {
                width: 95%;
                padding: 16px;
                max-height: 90vh;
            }

            .header h1 {
                font-size: 2em;
            }

            .header {
                padding: 16px;
            }

            .controls {
                padding: 16px;
            }

            .search-filters {
                justify-content: center;
            }
        }

        .file-input-wrapper:focus-within {
            outline: 2px solid #58a6ff;
            outline-offset: 2px;
        }

        .entry-card:focus {
            outline: 2px solid #58a6ff;
            outline-offset: 2px;
        }

        ::selection {
            background: #58a6ff;
            color: #ffffff;
        }

        a {
            color: #58a6ff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
        
        .filter-sort-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 16px;
        }

        .search-filters {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .sort-options {
            display: flex;
            gap: 8px;
        }
        
        /* Theme Toggle Button */
.theme-toggle {
    position: absolute;
    top: 20px;
    right: 20px;
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    transition: all 0.2s ease;
    color: #58a6ff;
    z-index: 10;
}



.theme-toggle:hover {
    background: rgba(255, 255, 255, 0.1);
}

/* Light Theme Styles */
body.light-theme {
    background: #f0f2f5;
    color: #24292e;
}

.light-theme .header,
.light-theme .controls,
.light-theme .entry-card,
.light-theme .detail-item {
    background: #ffffff;
    border-color: #e1e4e8;
}

.light-theme .header h1 {
    color:  #58a6ff;
}

.light-theme .entry-title,
.light-theme .modal-title,
.light-theme .detail-value {
    color: #24292e;
}

.light-theme .entry-author,
.light-theme .detail-label {
    color: #0366d6;
}

.light-theme .search-input {
    background: #ffffff;
    color: #24292e;
    border-color: #e1e4e8;
}

.light-theme .search-input:focus {
    border-color: #0366d6;
    box-shadow: 0 0 0 2px rgba(3, 102, 214, 0.2);
}

.light-theme .modal-content {
    background: #ffffff;
    border-color: #e1e4e8;
}

.light-theme .empty-state {
    background: #ffffff;
    border-color: #e1e4e8;
}

.light-theme ::-webkit-scrollbar-track {
    background: #f6f8fa;
}

.light-theme ::-webkit-scrollbar-thumb {
    background: #d1d5da;
}

.light-theme .filter-btn,
.light-theme .sort-select {
    background: #f6f8fa;
    border-color: #e1e4e8;
    color: #586069;
}

.light-theme .filter-btn:hover,
.light-theme .sort-select:hover {
    background: #e1e4e8;
    border-color: #0366d6;
}

.light-theme .filter-btn.active {
    background: #0366d6;
    color: #ffffff;
}

.light-theme .stats {
    border-top-color: #e1e4e8;
}

.light-theme .entry-year {
    background: #f6f8fa;
    border-color: #e1e4e8;
    color: #24292e;
}
        
        
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
    <h1>📚 BibTeX Reader for JabRef</h1>
    <p>Search your BibTeX-Files</p>
  
</div>

        <div class="controls">
            <div class="file-input-container">
                <label class="file-input-wrapper">
                    <input type="file" id="fileInput" accept=".bib,.txt" />
                    📁 load BibTeX-file
                </label>
                  <button id="themeToggle" class="theme-toggle" title="Toggle light/dark mode">🌓</button>
            </div>

            <div class="search-container">
                <input type="text" id="searchInput" class="search-input" placeholder="Search...">
               <span class="search-icon" id="searchIcon" style="cursor: pointer;">🔍</span>
            </div>
          <div class="filter-sort-row">
            <div class="search-filters">
                <button class="filter-btn active" data-filter="all">All</button>
                <button class="filter-btn" data-filter="title">Title</button>
                <button class="filter-btn" data-filter="author">Author</button>
                <button class="filter-btn" data-filter="keywords">Keywords</button>
                <button class="filter-btn" data-filter="groups">Groups</button>
            </div>

            <div class="sort-options">
                <select id="sortField" class="sort-select">
                    <option value="none">No sorting</option>
                    <option value="year">Year</option>
                    <option value="creationdate">Creation Date</option>
                </select>
                <select id="sortDirection" class="sort-select">
                    <option value="desc">ascending</option>
                    <option value="asc">descending</option>
                </select>
            </div>
           </div>
            <div class="stats">
                <span id="entriesCount">0 Einträge geladen</span>
                <span id="filteredCount"></span>
            </div>
        </div>

        <div id="entriesContainer" class="entries-grid"></div>

        <div class="empty-state" id="emptyState">
            <div class="empty-state-icon">📄</div>
            <h3>Keine BibTeX-Datei geladen</h3>
            <p>Laden Sie eine .bib-Datei, um Ihre Einträge zu durchsuchen</p>
        </div>
    </div>

    <div id="detailModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
             
                <button class="close-btn" id="closeModal">&times;</button>
            </div>
            <div id="detailContent"></div>
        </div>
    </div>

    <div id="notification" class="notification"></div>

    <script>
        class BibTeXReader {
            constructor() {
                this.entries = [];
                this.filteredEntries = [];
                this.pinnedEntries = new Set();
                this.currentFilter = 'all';
                this.sortField = 'none';
                this.sortDirection = 'desc';
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.loadSampleData();
                const savedBib = localStorage.getItem('lastBibFile');
if (savedBib) {
    this.parseBibTeX(savedBib);
    this.showNotification("Restored saved data.");
}
                
                
                
                const searchInput = document.getElementById('searchInput');
                const searchIcon = document.getElementById('searchIcon');

// Theme Toggle Functionality
document.getElementById('themeToggle').addEventListener('click', () => {
    document.body.classList.toggle('light-theme');
    const isLight = document.body.classList.contains('light-theme');
    localStorage.setItem('theme', isLight ? 'light' : 'dark');
});

// Check for saved theme preference
if (localStorage.getItem('theme') === 'light') {
    document.body.classList.add('light-theme');
}

                searchInput.addEventListener('input', (e) => {
                    const value = e.target.value;
                    this.handleSearch(value);
                    if (value.length > 0) {
                        searchIcon.textContent = '❌';
                    } else {
                        searchIcon.textContent = '🔍';
                    }
                });

                searchIcon.addEventListener('click', () => {
                    if (searchInput.value.length > 0) {
                        searchInput.value = '';
                        searchIcon.textContent = '🔍';
                        this.handleSearch('');
                    }
                });
            }

            setupEventListeners() {
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    this.handleFileUpload(e);
                });

                document.getElementById('searchInput').addEventListener('input', (e) => {
                    this.handleSearch(e.target.value);
                });

                document.getElementById('closeModal').addEventListener('click', () => {
                    this.closeModal();
                });

                document.getElementById('detailModal').addEventListener('click', (e) => {
                    if (e.target.id === 'detailModal') {
                        this.closeModal();
                    }
                });

                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentFilter = e.target.dataset.filter;
                        this.handleSearch(document.getElementById('searchInput').value);
                    });
                });

                document.getElementById('sortField').addEventListener('change', (e) => {
                    this.sortField = e.target.value;
                    this.applySorting();
                    this.renderEntries();
                });

                document.getElementById('sortDirection').addEventListener('change', (e) => {
                    this.sortDirection = e.target.value;
                    this.applySorting();
                    this.renderEntries();
                });

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.closeModal();
                    }
                });
            }

            togglePin(entryKey, event) {
                event.stopPropagation();
                
                if (this.pinnedEntries.has(entryKey)) {
                    this.pinnedEntries.delete(entryKey);
                } else {
                    this.pinnedEntries.add(entryKey);
                }
                
                this.renderEntries();
            }

            applySorting() {
                if (this.sortField === 'none') {
                    return;
                }

                this.filteredEntries.sort((a, b) => {
                    let valA = a[this.sortField] || '';
                    let valB = b[this.sortField] || '';

                    if (this.sortField === 'year') {
                        valA = parseInt(valA) || 0;
                        valB = parseInt(valB) || 0;
                    }

                    if (this.sortField === 'creationdate') {
                        valA = new Date(valA).getTime() || 0;
                        valB = new Date(valB).getTime() || 0;
                    }

                    if (valA < valB) {
                        return this.sortDirection === 'asc' ? -1 : 1;
                    }
                    if (valA > valB) {
                        return this.sortDirection === 'asc' ? 1 : -1;
                    }
                    return 0;
                });
            }

            handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    this.parseBibTeX(content);
                    this.showNotification(`${this.entries.length} entries loaded!`);
                    localStorage.setItem('lastBibFile', content); // speichert den Inhalt
                };
                reader.readAsText(file);
            }

            parseBibTeX(content) {
                const entries = [];
                const lines = content.split('\n');
                let currentEntry = null;
                let inEntry = false;
                let fieldBuffer = '';

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    if (line.startsWith('@comment') || line.startsWith('@Comment')) {
                        continue;
                    }

                    if (line.match(/^@\w+\{/) && !line.startsWith('@comment') && !line.startsWith('@Comment')) {
                        if (currentEntry) {
                            entries.push(currentEntry);
                        }

                        const match = line.match(/^@(\w+)\{([^,]+),?/);
                        if (match) {
                            currentEntry = {
                                type: match[1],
                                key: match[2],
                                author: '',
                                title: '',
                                year: '',
                                journal: '',
                                publisher: '',
                                keywords: '',
                                abstract: '',
                                doi: '',
                                pages: '',
                                volume: '',
                                number: '',
                                issn: '',
                                isbn: '',
                                address: '',
                                booktitle: '',
                                editor: '',
                                url: '',
                                note: '',
                                file: '',
                                groups: '',
                                priority: '',
                                ranking: '',
                                readstatus: '',
                                month: '',
                                subtitle: '',
                                creationdate: ''
                            };
                            inEntry = true;
                            fieldBuffer = '';
                        }
                    }
                    else if (line === '}' && inEntry) {
                        if (fieldBuffer) {
                            this.parseField(currentEntry, fieldBuffer);
                        }
                        if (currentEntry) {
                            entries.push(currentEntry);
                        }
                        currentEntry = null;
                        inEntry = false;
                        fieldBuffer = '';
                    }
                    else if (inEntry && line.length > 0) {
                        if (line.includes('=')) {
                            if (fieldBuffer) {
                                this.parseField(currentEntry, fieldBuffer);
                            }
                            fieldBuffer = line;
                        } else {
                            fieldBuffer += '\n' + line;
                        }
                    }
                }

                this.entries = entries;
                this.filteredEntries = [...entries];
                this.applySorting();
                this.renderEntries();
                this.updateStats();
            }

            parseField(entry, fieldStr) {
                const match = fieldStr.match(/^\s*(\w+)\s*=\s*(.+)/s);
                if (match) {
                    const fieldName = match[1].toLowerCase();
                    let fieldValue = match[2];

                    fieldValue = fieldValue.replace(/,$/, '');
                    fieldValue = fieldValue.replace(/^\{/, '').replace(/\}$/, '');
                    fieldValue = fieldValue.replace(/^"/, '').replace(/"$/, '');

                    if (fieldName === "abstract") {
                        fieldValue = fieldValue.replace(/\\&/g, '&').replace(/\\\$/g, '$');
                        fieldValue = fieldValue.trim();
                    } else {
                        fieldValue = fieldValue.replace(/\{\\"([^}]+)\\"?\}?/g, '"$1');
                        fieldValue = fieldValue.replace(/\\&/g, '&');
                        fieldValue = fieldValue.replace(/\\\$/g, '$');
                        fieldValue = fieldValue.replace(/\{([^}]+)\}/g, '$1');
                        fieldValue = fieldValue.trim();
                    }

                    if (entry.hasOwnProperty(fieldName)) {
                        entry[fieldName] = fieldValue;
                    }
                }
            }

            handleSearch(query) {
                if (!query || query.length === 0) {
                    this.filteredEntries = [...this.entries];
                } else {
                    const searchText = query.toLowerCase();
                    this.filteredEntries = this.entries.filter(entry => {
                        switch (this.currentFilter) {
                            case 'title':
                                return entry.title.toLowerCase().includes(searchText);
                            case 'author':
                                return entry.author.toLowerCase().includes(searchText);
                            case 'keywords':
                                return entry.keywords.toLowerCase().includes(searchText);
                            case 'groups':
                                return entry.groups.toLowerCase().includes(searchText);
                            case 'all':
                            default:
                                return entry.author.toLowerCase().includes(searchText) ||
                                       entry.title.toLowerCase().includes(searchText) ||
                                       entry.keywords.toLowerCase().includes(searchText) ||
                                       entry.abstract.toLowerCase().includes(searchText) ||
                                       entry.journal.toLowerCase().includes(searchText) ||
                                       entry.publisher.toLowerCase().includes(searchText) ||
                                       entry.groups.toLowerCase().includes(searchText) ||
                                       entry.year.includes(searchText);
                        }
                    });
                }
                
                this.applySorting();
                this.renderEntries();
                this.updateStats();
            }

            getRankingStars(ranking) {
                const numericValue = ranking.toString().replace(/[^0-9]/g, '');
                const rank = parseInt(numericValue);
                if (isNaN(rank) || rank < 1 || rank > 5) return '';
                
                const stars = '★'.repeat(rank) + '☆'.repeat(5 - rank);
                return stars;
            }

            renderEntries() {
                const container = document.getElementById('entriesContainer');
                const emptyState = document.getElementById('emptyState');

                if (this.entries.length === 0) {
                    container.style.display = 'none';
                    emptyState.style.display = 'block';
                    return;
                }

                container.style.display = 'grid';
                emptyState.style.display = 'none';

                // Gepinnte und nicht gepinnte Einträge trennen
                const pinnedEntries = this.filteredEntries.filter(entry => this.pinnedEntries.has(entry.key));
                const unpinnedEntries = this.filteredEntries.filter(entry => !this.pinnedEntries.has(entry.key));
                
                // Zuerst gepinnte, dann ungepinnte Einträge
                const sortedEntries = [...pinnedEntries, ...unpinnedEntries];

                container.innerHTML = sortedEntries.map(entry => {
                    const entryIndex = this.entries.indexOf(entry);
                    const isPinned = this.pinnedEntries.has(entry.key);
                    const priorityFlag = entry.priority === 'prio1' ? '<span class="entry-priority">🚩</span>' : '';
                    const rankingStars = this.getRankingStars(entry.ranking);
                    const rankingDisplay = rankingStars ? `<span class="entry-ranking">${rankingStars}</span>` : '';
                    
                    return `
                        <div class="entry-card ${isPinned ? 'pinned' : ''}" onclick="bibReader.showDetail(${entryIndex})" tabindex="0">
                            <button class="pin-btn ${isPinned ? 'pinned' : ''}" onclick="bibReader.togglePin('${entry.key}', event)" title="${isPinned ? 'Unpin' : 'Pin'}">
                                ${isPinned ? '📌' : '📍'}
                            </button>
                            <div class="entry-author">${entry.author}</div>
                            <div class="entry-title">${entry.title}</div>
                            <div class="entry-meta">
                                <span>${entry.journal || entry.publisher}</span>
                                <span class="entry-year">${entry.year}</span>
                            </div>
                            ${entry.keywords ? `<div class="entry-keywords">🏷️ ${entry.keywords}</div>` : ''}
                            <div class="entry-indicators">
                                ${priorityFlag}
                                ${rankingDisplay}
                            </div>
                        </div>
                    `;
                }).join('');
            }

makeLinksClickable(text) {
    if (!text) return text;

    // URLs zuerst verlinken (nur wenn nicht schon ein <a>)
    text = text.replace(
        /(?<!["'>])(https?:\/\/[^\s<]+)/g,
        '<a href="$1" target="_blank">$1</a>'
    );

    // DOIs verlinken, aber nur wenn sie NICHT in einer URL stehen
    text = text.replace(
        /(?<!["\/>])(10\.\d{4,}\/[^\s<]+)/g,
        '<a href="https://doi.org/$1" target="_blank">$1</a>'
    );

    return text;
}
            preserveLineBreaks(text) {
                if (!text) return text;
                return text.replace(/\n/g, '<br>');
            }

            parseMarkdown(text) {
                if (!text) return '';

                let lines = text.split('\n').map(line => line.trim());
                let html = '';
                let inList = false;
                let inSubList = false;

                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i];

                    // ### h3
                    if (line.startsWith('### ')) {
                        if (inList) {
                            if (inSubList) html += '</ul>';
                            html += '</ul>';
                            inList = inSubList = false;
                        }
                        html += `<h3>${line.substring(4)}</h3>`;
                        continue;
                    }

                    // ## h2
                    if (line.startsWith('## ')) {
                        if (inList) {
                            if (inSubList) html += '</ul>';
                            html += '</ul>';
                            inList = inSubList = false;
                        }
                        html += `<h2>${line.substring(3)}</h2>`;
                        continue;
                    }

                    // # h1
                    if (line.startsWith('# ')) {
                        if (inList) {
                            if (inSubList) html += '</ul>';
                            html += '</ul>';
                            inList = inSubList = false;
                        }
                        html += `<h1>${line.substring(2)}</h1>`;
                        continue;
                    }

                    // Listen
                    if (line.startsWith('- ') || line.match(/^\s{2,4}- /)) {
                        const isSubItem = line.match(/^\s{2,4}- /);
                        if (isSubItem) {
                            if (!inSubList) {
                                html += '<ul>';
                                inSubList = true;
                            }
                            line = line.replace(/^\s{2,4}-\s/, '');
                        } else {
                            if (inSubList) {
                                html += '</ul>';
                                inSubList = false;
                            }
                            if (!inList) {
                                html += '<ul>';
                                inList = true;
                            }
                            line = line.substring(2);
                        }

                        line = line
                            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                            .replace(/\*(.*?)\*/g, '<em>$1</em>')
                            .replace(/__(.*?)__/g, '<u>$1</u>');

                        html += `<li>${line}</li>`;
                        continue;
                    }

                    if (inList && line.length > 0) {
                        line = line
                            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                            .replace(/\*(.*?)\*/g, '<em>$1</em>')
                            .replace(/__(.*?)__/g, '<u>$1</u>');
                        if (inSubList) {
                            html += ` ${line}`;
                        } else {
                            html += ` ${line}`;
                        }
                        continue;
                    }

                    if (line.length > 0) {
                        line = line
                            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                            .replace(/\*(.*?)\*/g, '<em>$1</em>')
                            .replace(/__(.*?)__/g, '<u>$1</u>');
                        html += `<p>${line}</p>`;
                    }
                }

                if (inSubList) html += '</ul>';
                if (inList) html += '</ul>';

                return html;
            }

            showDetail(index) {
                const entry = this.entries[index];
                const modal = document.getElementById('detailModal');
                const content = document.getElementById('detailContent');

                const fields = [
                    { key: 'abstract', label: 'Abstract' },
                    { key: 'type', label: 'type' },
                    { key: 'key', label: 'Bibtexkey' },
                    { key: 'author', label: 'Author(s)' },
                    { key: 'title', label: 'Title' },
                    { key: 'subtitle', label: 'Subtitle' },
                    { key: 'year', label: 'Year' },
                    { key: 'journal', label: 'Journal' },
                    { key: 'publisher', label: 'Publisher' },
                    { key: 'volume', label: 'Volume' },
                    { key: 'number', label: 'Number' },
                    { key: 'pages', label: 'Pages' },
                    { key: 'doi', label: 'DOI' },
                    { key: 'isbn', label: 'ISBN' },
                    { key: 'issn', label: 'ISSN' },
                    { key: 'address', label: 'Address' },
                    { key: 'booktitle', label: 'Booktitle' },
                    { key: 'editor', label: 'Editor(s)' },
                    { key: 'keywords', label: 'Keywords' },
                    { key: 'url', label: 'URL' },
                    { key: 'note', label: 'Note' },
               //     { key: 'file', label: 'File' },
                    { key: 'groups', label: 'Groups' },
               //     { key: 'priority', label: 'Priority' },
                    { key: 'ranking', label: 'Ranking' },
                    { key: 'readstatus', label: 'Readstatus' },
                    { key: 'creationdate', label: 'Creationdate' }
                ];

                content.innerHTML = fields
                    .filter(field => entry[field.key] && entry[field.key].trim().length > 0)
                    .map(field => {
                        let value = entry[field.key];
                        
                        if (field.key === 'abstract') {
                            value = this.parseMarkdown(value);
                            value = this.makeLinksClickable(value);
                            value = `<div class="abstract-content">${value}</div>`;
                        } else if (field.key === 'url' || field.key === 'doi') {
                            value = this.makeLinksClickable(value);
                        } else if (field.key === 'ranking') {
                            const stars = this.getRankingStars(value);
                            value = stars ? `${stars}` : value;
                        } else {
                            value = this.makeLinksClickable(value);
                        }
                        
                        return `
                            <div class="detail-item">
                                <div class="detail-label">${field.label}</div>
                                <div class="detail-value">${value}</div>
                            </div>
                        `;
                    }).join('');

                modal.style.display = 'block';
            }

            closeModal() {
                document.getElementById('detailModal').style.display = 'none';
            }

            updateStats() {
                document.getElementById('entriesCount').textContent = `${this.entries.length} entries loaded`;
                document.getElementById('filteredCount').textContent = 
                    this.filteredEntries.length !== this.entries.length 
                        ? `${this.filteredEntries.length} filtered` 
                        : '';
            }

            showNotification(message) {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.classList.add('show');
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }

            loadSampleData() {
                const sampleBibTeX = `@Article{KuehnelWilke2025a,
  author       = {Elias Kühnel and Wilke, Felix},
  journal      = {Frontiers in Public Health},
  title        = {Health Data Sharing in Germany: Individual Preconditions, Trust and Motives},
  year         = {2025},
  creationdate = {2025-02-02T16:47:48},
  month        = aug,
  volume       = {13},
   priority     = {prio1},
  ranking      = {rank5}, 
    keywords    = {Health, Trust, Data sharing},
  abstract     = {**Objective:** The use of health data plays an important role in medical research. In Germany, the secondary use of health data is not yet as established as in other countries. In order to exploit the full potential of using health data, a key prerequisite is that a large part of the population is willing to share their health data. The aim of this study is to identify attitudes and factors that influence citizens’ willingness to share personal health data for medical research purposes.

**Methods:** A standardized cross-sectional telephone survey was conducted among the German population aged 18 and above. The representative survey of a total of 1,004 people took place from December 7th to 21th, 2023. Multiple linear regression analyses were conducted to identify potential factors influencing the willingness to share health data.

**Results:** Around 43% of respondents are willing to share their health data with public research institutions, while around 17% are still undecided. The population, however, is particularly skeptical about data being shared with commercial companies. Less than a quarter of respondents (23%) would share their data with small and medium-sized enterprises and only 15 percent with technology companies. Regarding the factors influencing the willingness to share data with research institutions, three overarching factors can be named: (1) individual characteristics, in particular the level of education and technical competence, (2) individual motives, such as altruism as well as worries and concerns regarding health data sharing, and (3) trust in institutions, especially trust in science and technology companies.

**Discussion and conclusion:** Although the study shows a general openness towards sharing health data and underlines the importance of altruistic motives, social inequalities and concerns about health data sharing are also evident. Trust plays a particularly important role here, as it acts as a mediator between individual preconditions and individual motives. In order to exploit the full potential of secondary data use in medical research, comprehensive information of the public about data sharing and use as well as transparent and open communication are required to strengthen trust in the actors involved and the data sharing process.},
  doi          = {10.3389/fpubh.2025.1538106},
  file         = {:KuehnelWilke2025a.pdf:PDF},
}

@Article{Wilke2024b,
  author       = {Wilke, Felix},
  journal      = {JMIR Human Factors},
  title        = {Willingness to Share Health Data via Electronic Health Records in Germany: The Impact of Trust and the Role of the Opt-Out Mechanism},
  year         = {2025},
  creationdate = {2024-10-29T16:57:05},
  month        = aug,
  number       = {65718},
  doi          = {10.2196/65718},
  file         = {:Wilke2024b.pdf:PDF},
  keywords    = {Health, Trust, Social Policy},
  publisher    = {JMIR Publications Inc.},
}


@Collection{OpielkaWilke2024a,
  address      = {Wiesbaden},
  author       = {Michael Opielka and Felix Wilke},
  publisher    = {Springer VS},
  title        = {Der weite Weg zum Bürgergeld},
  year         = {2024},
  creationdate = {2024-08-26T13:39:28},
  doi          = {10.1007/978-3-658-43475-5},
  file         = {:OpielkaWilke2024a.pdf:PDF},
  isbn         = {9783658434755},
  groups    = {Books, Social Policy},
  keywords    = {Labor Market, Social Policy},
  url          = {https://link.springer.com/book/10.1007/978-3-658-43475-5},
}
@Other{Wilke2020,
  abstract  = {Open source application for Linux and Windows. Using this tool you can easily create a custom export filter for JabRef to build you own bibliography style. It supports: - HTML Export Filter - RTF Export Filter - OpenOffice/ LibreOffice Style File - saving the filter for later refinements},
  author    = {Felix Wilke},
  comment   = {"Export Filter Editor for Jabref is an intuitive and lightweight application designed to help you create custom bibliographic references with Jabref.You can use it to define your own bibliography style, configure in-text citation properties, text style and formatting options. The application generates HTML and RTF code, in order to help you export the bibliographic references." (http://www.softpedia.com/get/Office-tools/Other-Office-Tools/Export-Filter-Editor-for-Jabref.shtml)},
  groups    = {Software},
  keywords  = {Software, Editor, Literaturverwaltung, Bibliografie},
  note      = {14},
  timestamp = {2013.09.24},
  title     = {Export-Filter Editor. GUI Editor to create Custom Bibliographies with JabRef},
  url       = {https://github.com/teertinker/Export-Filter-Editor},
  year      = {2020},
     priority     = {prio1},
  ranking      = {rank3}, 
}

`;

                this.parseBibTeX(sampleBibTeX);
             }
        }

        // Initialize the app
        const bibReader = new BibTeXReader();
    </script>
</body>
</html>
